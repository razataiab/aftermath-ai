diff --git a/changes.patch b/changes.patch
index fb320fb..e69de29 100644
--- a/changes.patch
+++ b/changes.patch
@@ -1,285 +0,0 @@
-diff --git a/src/app/core/config.py b/src/app/core/config.py
-index 8d665e2..fc12539 100644
---- a/src/app/core/config.py
-+++ b/src/app/core/config.py
-@@ -3,11 +3,11 @@ from pydantic_settings import BaseSettings
- class Settings(BaseSettings):
-     SLACK_TOKEN: str
-     SLACK_SIGNING_SECRET: str
--    # OPENAI_API_KEY: str
-+    OPENAI_API_KEY: str
-     CORS_ORIGINS: list[str] = ["*"]
-     ENV: str = "development"
- 
-     class Config:
--        env_file = "../.env"
-+        env_file = ".env"
- 
- settings = Settings()
-diff --git a/src/app/core/models.py b/src/app/core/models.py
-index f14fc95..453ef36 100644
---- a/src/app/core/models.py
-+++ b/src/app/core/models.py
-@@ -1,6 +1,6 @@
--from datetime import datetime
-+from pydantic import BaseModel
- from typing import List
--from pydantic import BaseModel, Field
-+from datetime import datetime
- 
- class Message(BaseModel):
-     user_id: str
-@@ -8,14 +8,10 @@ class Message(BaseModel):
-     text: str
-     timestamp: datetime
- 
--class Conversation(BaseModel):
--    channel_id: str
--    channel_name: str
--    messages: List[Message]
--
--class PostmortemRun(BaseModel):
-+class Incident(BaseModel):         
-     incident_id: str
-     channel_id: str
--    run_id: str
--    run_timestamp: datetime
--    invoked_by: str
-+    triggered_by_user_id: str
-+    triggered_by_user_name: str
-+    channel_name: str
-+    conversation: List[Message]
-\ No newline at end of file
-diff --git a/src/app/main.py b/src/app/main.py
-index ce821a5..f944f8f 100644
---- a/src/app/main.py
-+++ b/src/app/main.py
-@@ -4,8 +4,7 @@ from fastapi.responses import JSONResponse
- from slack_sdk.signature import SignatureVerifier
- import uvicorn
- from src.app.core.config import settings
--from api import slack
--from api.slack import verify_slack_signature, handle_slash_command
-+from src.app.api.v1.reports import router as slack_router
- 
- verifier = SignatureVerifier(settings.SLACK_SIGNING_SECRET)
- 
-@@ -28,11 +27,12 @@ def create_app() -> FastAPI:
-     async def health():
-         return {"status": "ok"}
-     
--    app.include_router(slack.router, prefix="", tags=["Slack Integration"])
-+    app.include_router(slack_router, prefix="/api/v1", tags=["Slack Integration"])
- 
-     return app
- 
-+app = create_app()
-+
- if __name__ == "__main__":
--    app = create_app()
-     print("Starting local server at http://127.0.0.1:8000")
-     uvicorn.run(app, host="0.0.0.0", port=8000, reload=False)
-\ No newline at end of file
-diff --git a/src/ingestion/connectors/slack_connector.py b/src/ingestion/connectors/slack_connector.py
-index 5765c53..0400da2 100644
---- a/src/ingestion/connectors/slack_connector.py
-+++ b/src/ingestion/connectors/slack_connector.py
-@@ -9,11 +9,9 @@ verifier = SignatureVerifier(settings.SLACK_SIGNING_SECRET)
- def verify_slack_signature(request: Request, body: bytes):
-     timestamp = request.headers.get("X-Slack-Request-Timestamp")
-     signature = request.headers.get("X-Slack-Signature")
--    print("Verifying signature:")
-     verified = verifier.is_valid(body, timestamp, signature)
-     if not verified:
--        print("Signature verification failed!")
--    print("Signature verified successfully!")
-+        print("Signature verification failed: Invalid signature")
- 
- async def retrieve_slack_chat_history(channel_id: str):
-     response = client.conversations_history(channel=channel_id)
-@@ -25,3 +23,15 @@ async def retrieve_slack_user_name(user_id: str):
- 
- async def send_slack_message(channel_id: str, message: str):
-     client.chat_postMessage(channel=channel_id, text=message)
-+
-+# async def get_channel_id(body: bytes):
-+#     payload = slack_parser.parse_slash_payload(body)
-+#     return payload.get("channel_id")
-+
-+# async def get_user_id(body: bytes):
-+#     payload = slack_parser.parse_slash_payload(body)
-+#     return payload.get("user_id")
-+
-+# async def get_channel_name(body: bytes):
-+#     payload = slack_parser.parse_slash_payload(body)
-+#     return payload.get("channel_name")
-\ No newline at end of file
-diff --git a/src/ingestion/parsers/slack_parser.py b/src/ingestion/parsers/slack_parser.py
-index 607057c..f408ceb 100644
---- a/src/ingestion/parsers/slack_parser.py
-+++ b/src/ingestion/parsers/slack_parser.py
-@@ -1,3 +1,4 @@
-+from typing import List
- from urllib.parse import parse_qs
- 
- def parse_slash_payload(body: bytes):
-diff --git a/src/llm/__init__.py b/src/llm/__init__.py
-index 6dd0c19..e3ad45a 100644
---- a/src/llm/__init__.py
-+++ b/src/llm/__init__.py
-@@ -1 +1 @@
--from .pipeline import generate_postmortem
-+# from .pipeline import generate_postmortem
-diff --git a/src/llm/pipeline.py b/src/llm/pipeline.py
-index f3e2cd5..0bdcac8 100644
---- a/src/llm/pipeline.py
-+++ b/src/llm/pipeline.py
-@@ -1,20 +1,26 @@
- from typing import List, Optional
--from langchain.chat_models import ChatOpenAI
-+from langchain_community.chat_models import ChatOpenAI
- from langchain.schema import AIMessage, HumanMessage, SystemMessage
- from langchain.tools import Tool
- from langchain.agents import initialize_agent, AgentType
--import asyncio
- 
--from src.ingestion.connectors.slack_connector import retrieve_slack_chat_history, retrieve_slack_user_name
-+from src.app.core.config import settings
-+from src.app.core.models import Incident
-+
-+OPENAI_API_KEY = settings.OPENAI_API_KEY
- 
- class ModelClient:
-     def __init__(self, provider: str = "openai", model_name: str = "gpt-5-postmortem"):
-         self.provider = provider
-         self.model_name = model_name
--        self.client = ChatOpenAI(model=model_name, temperature=0.3)
-+        self.client = ChatOpenAI(
-+            model=model_name,
-+            temperature=0.3,
-+            openai_api_key=OPENAI_API_KEY
-+        )
- 
-     @classmethod
--    def select(cls, provider: str = "openai", model_name: str = "gpt-5-postmortem") -> "ModelClient":
-+    def select(cls, provider: str = "openai", model_name: str = "gpt-4o") -> "ModelClient":
-         return cls(provider, model_name)
- 
-     def generate(self, messages: List[dict]) -> str:
-@@ -27,16 +33,19 @@ class ModelClient:
-         response = self.client(lc_msgs)
-         return response.content
- 
-+
- POSTMORTEM_TEMPLATE = """
- You are a senior SRE generating an incident postmortem.
-+
- Context:
- {{context}}
- 
- Instructions:
- - Deliver a structured postmortem with clear root cause
--- Timeline must be explicit
--- No filler phrases
--- Cite sources (slack/github/deploy-log) inline
-+- Timeline must be explicit (chronological)
-+- No filler language
-+- Cite message sources inline using user_id
-+- Everything MUST come from the provided incident context
- 
- Output format:
- 1. Summary
-@@ -45,41 +54,58 @@ Output format:
- 4. Root Cause
- 5. Remediations
- 6. Follow-ups
--"""
-+""".strip()
-+
- 
- class AgentState(dict):
-     def __init__(self, **kwargs):
-         super().__init__(**kwargs)
--        self.setdefault("context", {})
-+        self.setdefault("incident", None)
-         self.setdefault("postmortem", None)
-+        self.setdefault("valid", False)
-+
-+
-+def build_slack_context(incident: Incident) -> str:
-+    """Format the Slack conversation as `user_id: message` per line."""
-+    lines = []
-+    for msg in incident.conversation:
-+        # No username here — exactly what you asked for
-+        lines.append(f"{msg.user_id}: {msg.text}")
-+    return "\n".join(lines)
-+
-+
-+def slack_tool_func(state: AgentState) -> str:
-+    """Actual implementation of Slack tool that reads from Incident."""
-+    incident: Incident = state["incident"]
-+    return build_slack_context(incident)
- 
--def fetch_slack_context(incident_id: str) -> str:
--    return f"Slack discussion snippet for {incident_id}"
- 
- slack_tool = Tool(
--    name="Slack",
--    func=fetch_slack_context,
--    description="Fetch relevant Slack messages for an incident"
-+    name="SlackContext",
-+    func=lambda incident_id_or_state: slack_tool_func(incident_id_or_state),
-+    description="Returns previously ingested Slack messages for this incident.",
- )
- 
- TOOLS = [slack_tool]
- 
-+
- def synthesize_postmortem(state: AgentState, model: ModelClient):
-     llm_agent = initialize_agent(
-         tools=TOOLS,
-         llm=model.client,
--        agent=AgentType.CHAT_CONVERSATIONAL_REACT_DESCRIPTION,
-+        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
-         verbose=False
-     )
- 
--    prompt = POSTMORTEM_TEMPLATE.replace(
--        "{{context}}",
--        f"Incident ID: {state.get('incident_id')}\nPlease fetch Slack/GitHub/deploy logs as needed."
--    )
-+    incident: Incident = state["incident"]
-+    context = build_slack_context(incident)
-+
-+    prompt = POSTMORTEM_TEMPLATE.replace("{{context}}", context)
- 
-     state["postmortem"] = llm_agent.run(prompt)
-     return state
- 
-+
- def validate_postmortem(state: AgentState, model: ModelClient):
-     check_query = f"Is the following postmortem complete and properly formatted? Respond YES or NO.\n\n{state['postmortem']}"
-     res = model.generate([
-@@ -89,18 +115,20 @@ def validate_postmortem(state: AgentState, model: ModelClient):
-     state["valid"] = "YES" in res.upper()
-     return state
- 
-+
- class PostmortemAgent:
-     def __init__(self, model_client: Optional[ModelClient] = None):
-         self.model = model_client or ModelClient.select()
- 
--    def run(self, incident_id: str, initial_context: dict) -> str:
--        state = AgentState(incident_id=incident_id, context=initial_context)
-+    def run(self, incident: Incident) -> str:
-+        state = AgentState(incident=incident)
- 
-         state = synthesize_postmortem(state, self.model)
-         state = validate_postmortem(state, self.model)
- 
-         return state.get("postmortem", "No output generated.")
- 
-+
- __all__ = [
-     "ModelClient",
-     "PostmortemAgent",
diff --git a/src/app/api/v1/reports.py b/src/app/api/v1/reports.py
index 71779b9..143464b 100644
--- a/src/app/api/v1/reports.py
+++ b/src/app/api/v1/reports.py
@@ -1,18 +1,29 @@
 from datetime import datetime
 from typing import List, Optional
-import asyncio
 import uuid
 
 from fastapi import APIRouter, Request, BackgroundTasks
-from fastapi.responses import PlainTextResponse
+from fastapi.responses import PlainTextResponse, JSONResponse
 
 from src.app.core.models import Incident, Message
-from src.ingestion.parsers import slack_parser
+from src.ingestion.parsers import slack_parser, discord_parser, teams_parser
 from src.ingestion.connectors.slack_connector import (
-    verify_slack_signature, 
-    send_slack_message, 
-    retrieve_slack_chat_history, 
-    retrieve_slack_user_name
+    verify_slack_signature,
+    retrieve_slack_chat_history,
+    retrieve_slack_user_name,
+    send_slack_message,
+)
+from src.ingestion.connectors.discord_connector import (
+    verify_discord_signature,
+    retrieve_discord_chat_history,
+    retrieve_discord_user_name,
+    send_discord_message,
+)
+from src.ingestion.connectors.teams_connector import (
+    verify_teams_request,
+    retrieve_teams_chat_history,
+    retrieve_teams_user_name,
+    send_teams_message,
 )
 from src.llm.pipeline import PostmortemAgent
 
@@ -22,15 +33,18 @@ async def generate_and_send_postmortem(incident: Incident):
     agent = PostmortemAgent()
     postmortem = agent.run(incident)
 
-    await send_slack_message(
-        incident.channel_id, 
-        f"*Postmortem for incident `{incident.incident_id}`:*\n\n{postmortem}"
-    )
+    if incident.source == "slack":
+        await send_slack_message(incident.channel_id, f"*Postmortem for incident `{incident.incident_id}`:*\n\n{postmortem}")
+    elif incident.source == "discord":
+        await send_discord_message(incident.channel_id, f"**Postmortem for incident `{incident.incident_id}`**\n\n{postmortem}")
+    elif incident.source == "teams":
+        await send_teams_message(incident.channel_id, f"**Postmortem for incident `{incident.incident_id}`**\n\n{postmortem}")
+    else:
+        print("Unknown incident source; no outbound message sent.")
 
 @router.post("/slack")
 async def handle_slack_command(request: Request, background_tasks: BackgroundTasks):
     body: bytes = await request.body()
-
     verify_slack_signature(request, body)
     payload = slack_parser.parse_slash_payload(body)
 
@@ -44,10 +58,11 @@ async def handle_slack_command(request: Request, background_tasks: BackgroundTas
     for msg in messages:
         conversation.append(
             Message(
-                user_id=msg["user"],
-                username=await retrieve_slack_user_name(user_id) or "Unknown",
-                text=msg["text"],
-                timestamp=datetime.fromtimestamp(float(msg["ts"]))
+                user_id=msg.get("user","unknown"),
+                username=await retrieve_slack_user_name(msg.get("user")) or "Unknown",
+                text=msg.get("text",""),
+                timestamp=datetime.fromtimestamp(float(msg.get("ts", 0))),
+                source="slack"
             )
         )
 
@@ -57,9 +72,100 @@ async def handle_slack_command(request: Request, background_tasks: BackgroundTas
         triggered_by_user_id=user_id,
         triggered_by_user_name=user_name,
         channel_name=channel_name,
-        conversation=conversation
+        conversation=conversation,
+        source="slack",
+        trigger_platform="slack_slash"
     )
 
     background_tasks.add_task(generate_and_send_postmortem, incident)
+    return PlainTextResponse("Generating postmortem...", status_code=200)
+
+@router.post("/discord")
+async def handle_discord_interaction(request: Request, background_tasks: BackgroundTasks):
+    body: bytes = await request.body()
+
+    verify_discord_signature(request, body)
+
+    payload = await request.json()
+    parsed = discord_parser.parse_interaction_payload(payload)
+
+    channel_id = parsed.get("channel_id")
+    user_id = parsed.get("user_id")
+    user_name = await retrieve_discord_user_name(user_id)
+    channel_name = parsed.get("channel_name")
+
+    messages = await retrieve_discord_chat_history(channel_id)
+    conversation: List[Message] = []
+    for msg in messages:
+        conversation.append(
+            Message(
+                user_id=msg.get("author", {}).get("id", "unknown"),
+                username=msg.get("author", {}).get("username") or "Unknown",
+                text=msg.get("content", ""),
+                timestamp=datetime.fromtimestamp(float(msg.get("timestamp", datetime.utcnow().timestamp()))),
+                source="discord"
+            )
+        )
 
+    incident = Incident(
+        incident_id=str(uuid.uuid4()),
+        channel_id=channel_id,
+        triggered_by_user_id=user_id,
+        triggered_by_user_name=user_name,
+        channel_name=channel_name,
+        conversation=conversation,
+        source="discord",
+        trigger_platform=parsed.get("trigger_platform", "discord_interaction")
+    )
+
+    background_tasks.add_task(generate_and_send_postmortem, incident)
+    return JSONResponse({"type": 200, "message": "Postmortem generation started."})
+
+@router.post("/teams")
+async def handle_teams_trigger(request: Request, background_tasks: BackgroundTasks):
+    """
+    Endpoint that accepts triggers from multiple Platforms:
+      - teams:channel_message (Graph webhook)
+      - teams:incoming_webhook
+      - teams:adaptive_card (action)
+      - power_automate
+    The payload should include enough context (channelId or conversationId). Parsers attempt to normalize common Teams payloads.
+    """
+    body: bytes = await request.body()
+    json_payload = await request.json()
+
+    verify_teams_request(request, body)
+
+    parsed = teams_parser.parse_trigger_payload(json_payload)
+    channel_id = parsed.get("channel_id")
+    user_id = parsed.get("user_id")
+    user_name = await retrieve_teams_user_name(user_id)
+    channel_name = parsed.get("channel_name")
+    trigger_platform = parsed.get("trigger_platform", "teams_webhook")
+
+    messages = await retrieve_teams_chat_history(channel_id)
+    conversation: List[Message] = []
+    for msg in messages:
+        conversation.append(
+            Message(
+                user_id=msg.get("from", {}).get("user", {}).get("id", "unknown"),
+                username=msg.get("from", {}).get("user", {}).get("displayName") or "Unknown",
+                text=msg.get("body", {}).get("content", ""),
+                timestamp=datetime.fromtimestamp(float(msg.get("createdDateTime", datetime.utcnow().timestamp()))),
+                source="teams"
+            )
+        )
+
+    incident = Incident(
+        incident_id=str(uuid.uuid4()),
+        channel_id=channel_id,
+        triggered_by_user_id=user_id,
+        triggered_by_user_name=user_name,
+        channel_name=channel_name,
+        conversation=conversation,
+        source="teams",
+        trigger_platform=trigger_platform
+    )
+
+    background_tasks.add_task(generate_and_send_postmortem, incident)
     return PlainTextResponse("Generating postmortem...", status_code=200)
diff --git a/src/app/core/config.py b/src/app/core/config.py
index fc12539..fd56c02 100644
--- a/src/app/core/config.py
+++ b/src/app/core/config.py
@@ -7,6 +7,12 @@ class Settings(BaseSettings):
     CORS_ORIGINS: list[str] = ["*"]
     ENV: str = "development"
 
+    DISCORD_TOKEN: str
+    DISCORD_PUBLIC_KEY: str
+    TEAMS_CLIENT_ID: str
+    TEAMS_CLIENT_SECRET: str
+    TEAMS_TENANT_ID: str
+    TEAMS_GRAPH_TOKEN: str
     class Config:
         env_file = ".env"
 
diff --git a/src/app/core/models.py b/src/app/core/models.py
index 453ef36..d8613ee 100644
--- a/src/app/core/models.py
+++ b/src/app/core/models.py
@@ -1,5 +1,5 @@
 from pydantic import BaseModel
-from typing import List
+from typing import List, Optional
 from datetime import datetime
 
 class Message(BaseModel):
@@ -7,11 +7,14 @@ class Message(BaseModel):
     username: str
     text: str
     timestamp: datetime
+    source: Optional[str] = None
 
-class Incident(BaseModel):         
+class Incident(BaseModel):
     incident_id: str
     channel_id: str
     triggered_by_user_id: str
     triggered_by_user_name: str
     channel_name: str
-    conversation: List[Message]
\ No newline at end of file
+    conversation: List[Message]
+    source: Optional[str] = "slack"
+    trigger_platform: Optional[str] = None
diff --git a/src/app/main.py b/src/app/main.py
index f944f8f..da2d36a 100644
--- a/src/app/main.py
+++ b/src/app/main.py
@@ -1,18 +1,15 @@
-from fastapi import FastAPI, Request, BackgroundTasks, HTTPException
+from fastapi import FastAPI
 from fastapi.middleware.cors import CORSMiddleware
-from fastapi.responses import JSONResponse
-from slack_sdk.signature import SignatureVerifier
 import uvicorn
-from src.app.core.config import settings
-from src.app.api.v1.reports import router as slack_router
 
-verifier = SignatureVerifier(settings.SLACK_SIGNING_SECRET)
+from src.app.core.config import settings
+from src.app.api.v1.reports import router as reports_router
 
 def create_app() -> FastAPI:
     app = FastAPI(
         title="Aftermath AI - Incident Postmortem Generator",
-        version="0.1.0",
-        description="AI agent that turns incident discussions + deploy logs into postmortem reports",
+        version="0.2.0",
+        description="AI agent that turns incident discussions + deploy logs into postmortem reports (Slack / Discord / Teams)",
     )
 
     app.add_middleware(
@@ -27,7 +24,7 @@ def create_app() -> FastAPI:
     async def health():
         return {"status": "ok"}
     
-    app.include_router(slack_router, prefix="/api/v1", tags=["Slack Integration"])
+    app.include_router(reports_router, prefix="/api/v1", tags=["Integrations"])
 
     return app
 
diff --git a/src/llm/pipeline.py b/src/llm/pipeline.py
index 5054273..560fb13 100644
--- a/src/llm/pipeline.py
+++ b/src/llm/pipeline.py
@@ -33,7 +33,6 @@ class ModelClient:
         response = self.client(lc_msgs)
         return response.content
 
-
 POSTMORTEM_TEMPLATE = """
 You are a senior SRE generating an incident postmortem.
 
@@ -44,7 +43,7 @@ Instructions:
 - Deliver a structured postmortem with clear root cause
 - Timeline must be explicit (chronological)
 - No filler language
-- Cite message sources inline using user_id
+- Cite message sources inline using user_id and source (e.g. user123@slack)
 - Everything MUST come from the provided incident context
 
 Output format:
@@ -56,7 +55,6 @@ Output format:
 6. Follow-ups
 """.strip()
 
-
 class AgentState(dict):
     def __init__(self, **kwargs):
         super().__init__(**kwargs)
@@ -64,30 +62,33 @@ class AgentState(dict):
         self.setdefault("postmortem", None)
         self.setdefault("valid", False)
 
-
-def build_slack_context(incident: Incident) -> str:
-    """Format the Slack conversation as `user_id: message` per line."""
+def build_multi_source_context(incident: Incident) -> str:
+    """
+    Format messages with source tags:
+      [slack] U123: message
+      [discord] 98765: message
+      [teams] S-1: message
+    """
     lines = []
     for msg in incident.conversation:
-        lines.append(f"{msg.user_id}: {msg.text}")
+        source = msg.source or incident.source or "unknown"
+        lines.append(f"[{source}] {msg.user_id}: {msg.text}")
     return "\n".join(lines)
 
-
 def slack_tool_func(state: AgentState) -> str:
-    """Actual implementation of Slack tool that reads from Incident."""
+    """Return formatted context (keeps compatibility with existing tools)"""
     incident: Incident = state["incident"]
-    return build_slack_context(incident)
-
+    return build_multi_source_context(incident)
 
+# Tools (kept generic — they consume the incident state)
 slack_tool = Tool(
-    name="SlackContext",
-    func=lambda incident_id_or_state: slack_tool_func(incident_id_or_state),
-    description="Returns previously ingested Slack messages for this incident.",
+    name="ConversationContext",
+    func=lambda incident_state: slack_tool_func(incident_state),
+    description="Returns previously ingested messages for this incident from any source (Slack/Discord/Teams).",
 )
 
 TOOLS = [slack_tool]
 
-
 def synthesize_postmortem(state: AgentState, model: ModelClient):
     llm_agent = initialize_agent(
         tools=TOOLS,
@@ -97,14 +98,13 @@ def synthesize_postmortem(state: AgentState, model: ModelClient):
     )
 
     incident: Incident = state["incident"]
-    context = build_slack_context(incident)
+    context = build_multi_source_context(incident)
 
     prompt = POSTMORTEM_TEMPLATE.replace("{{context}}", context)
 
     state["postmortem"] = llm_agent.run(prompt)
     return state
 
-
 def validate_postmortem(state: AgentState, model: ModelClient):
     check_query = f"Is the following postmortem complete and properly formatted? Respond YES or NO.\n\n{state['postmortem']}"
     res = model.generate([
@@ -114,23 +114,12 @@ def validate_postmortem(state: AgentState, model: ModelClient):
     state["valid"] = "YES" in res.upper()
     return state
 
-
 class PostmortemAgent:
     def __init__(self, model_client: Optional[ModelClient] = None):
         self.model = model_client or ModelClient.select()
 
     def run(self, incident: Incident) -> str:
         state = AgentState(incident=incident)
-
         state = synthesize_postmortem(state, self.model)
         state = validate_postmortem(state, self.model)
-
-        return state.get("postmortem", "No output generated.")
-
-
-__all__ = [
-    "ModelClient",
-    "PostmortemAgent",
-    "POSTMORTEM_TEMPLATE",
-    "AgentState",
-]
\ No newline at end of file
+        return state.get("postmortem", "No output generated.")
\ No newline at end of file
